<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FmDPS PvP Calculator (Skills) - FIXED</title>
<style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  margin: 20px;
  background: #f6f7f8;
}
.wrap {
  max-width: 640px;
  margin: 0 auto;
}
.card {
  background: #ffffff;
  border: 1px solid #ddd;
  padding: 16px;
  overflow: hidden;
}
h2 {
  margin: 0 0 10px;
}
.pvp-grid {
  display: grid;
  grid-template-columns: minmax(0, 1fr) 200px minmax(0, 1fr);
  gap: 8px 10px;
  align-items: center;
}
.head {
  font-weight: 800;
  padding: 6px 0;
}
.head.left {
  text-align: left;
}
.head.center {
  text-align: center;
}
.head.right {
  text-align: right;
}
.subhead {
  font-weight: 600;
  color: #444;
  padding: 0 0 6px;
}
.subhead.left {
  text-align: left;
}
.subhead.center {
  text-align: center;
}
.subhead.right {
  text-align: right;
}
.label {
  text-align: center;
  color: #333;
  font-weight: 650;
}
input[type="number"],
select {
  width: 60%;
  box-sizing: border-box;
}
.pvp-grid input[id^="them_"],
.pvp-grid select[id^="them_"] {
  text-align: right;
  margin-left: auto;
}
.sectionTitle {
  grid-column: 1 / -1;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #eee;
  font-weight: 900;
  color: #222;
  text-align: center;
}
.controls {
  display: grid;
  grid-template-columns: 1fr;
  justify-items: center;
  margin-top: 16px;
}
button {
  padding: 8px 14px;
  font-size: 1em;
  cursor: pointer;
}
.calcBtn {
  min-width: 340px;
  font-weight: 700;
}
.results {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin-top: 14px;
}
.resultCard {
  border: 1px solid #ddd;
  padding: 12px;
  background: #fff;
}
.centerBox {
  border: 1px solid #ddd;
  padding: 12px;
  background: #fff;
  margin-top: 12px;
  text-align: center;
}
.hpGrid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 8px;
  align-items: start;
}
.metric {
  font-weight: 800;
  font-size: 1.05em;
  margin-top: 6px;
}
.good {
  color: #0b5a2a;
}
.bad {
  color: #7a1111;
}
.highlight {
  font-size: 1.15em;
  font-weight: 800;
}
.muted {
  color: #555;
  margin-top: 6px;
  white-space: pre-wrap;
  font-size: 0.95em;
}
.note {
  color: #666;
  font-size: 0.92em;
  white-space: pre-wrap;
}
.pill {
  display: inline-block;
  padding: 2px 8px;
  border: 1px solid #ddd;
  border-radius: 999px;
  background: #fff;
  color: #444;
  font-size: 12px;
  margin-left: 8px;
}
.skillBox {
  border: 1px dashed #ddd;
  padding: 10px;
  border-radius: 8px;
  background: #fafafa;
  max-width: 100%;
  box-sizing: border-box;
}
.skillBox .row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 6px;
}
.skillBox .row > * {
  flex: 1;
  min-width: 0;
}
.skillBox select,
.skillBox input[type="number"] {
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}
.sideStack {
  display: grid;
  gap: 8px;
}
.compactLabel {
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 190px);
  align-items: center;
  gap: 12px;
}
.fixNotice {
  background: #fff3cd;
  border: 1px solid #ffc107;
  padding: 12px;
  margin-bottom: 16px;
  border-radius: 4px;
  color: #856404;
}
.fixNotice strong {
  color: #d39e00;
}
@media (max-width: 920px) {
  .pvp-grid {
    grid-template-columns: 1fr 1fr;
  }
  .head.center,
  .subhead.center {
    display: none;
  }
  .label {
    grid-column: 1 / -1;
    text-align: left;
  }
  .sectionTitle {
    grid-column: 1 / -1;
  }
  #skills_toggle {
    grid-column: 1 / -1;
    justify-content: center;
  }
  .skillsSpacer {
    display: none;
  }
  .controls {
    justify-items: stretch;
  }
  .calcBtn {
    width: 100%;
    min-width: 0;
  }
  .results {
    grid-template-columns: 1fr;
  }
  input[type="number"],
  select {
    width: 100%;
  }
}
.skillsToggle {
  display: flex;
  align-items: center;
  gap: 8px;
  justify-content: center;
  margin: 0;
}
</style>
</head>
<body>
<div class="wrap">
<div class="fixNotice">
  <strong>⚠️ FIXED VERSION</strong><br>
  This calculator now uses the correct formulas:<br>
  1. Critical hits properly weighted (non-crit + crit probabilities)<br>
  2. Attack speed uses tier-based intervals matching game mechanics<br>
  3. Double attacks include delay penalties (0.1s or 0.2s per double)
</div>
<div class="card">
<h2>PvP Calculator</h2>
<div class="pvp-grid" id="statsGrid">
<div class="head left">You</div>
<div class="head center">Stat</div>
<div class="head right">Them</div>

<div class="subhead left"><button type="button" id="you_clear">Clear</button></div>
<div class="subhead center"></div>
<div class="subhead right"><button type="button" id="them_clear">Clear</button></div>

<div class="sectionTitle">Damage</div>

<input type="number" id="you_e1_damage" value="0" step="any" />
<div class="label">Total Damage</div>
<input type="number" id="them_e1_damage" value="0" step="any" />

<input type="number" id="you_e1_speed" value="0" step="any" />
<div class="label">Attack Speed (%)</div>
<input type="number" id="them_e1_speed" value="0" step="any" />

<input type="number" id="you_e1_double" value="0" step="any" />
<div class="label">Double Chance (%)</div>
<input type="number" id="them_e1_double" value="0" step="any" />

<input type="number" id="you_e1_crit" value="0" step="any" />
<div class="label">Critical Chance (%)</div>
<input type="number" id="them_e1_crit" value="0" step="any" />

<input type="number" id="you_e1_critdmg" value="0" step="any" />
<div class="label">Critical Damage (%)</div>
<input type="number" id="them_e1_critdmg" value="0" step="any" />

<div class="sectionTitle">Survivability</div>

<input type="number" id="you_h_total" value="0" step="any" />
<div class="label">Total Health</div>
<input type="number" id="them_h_total" value="0" step="any" />

<input type="number" id="you_h_regen" value="0" step="any" />
<div class="label">Health Regen (%)</div>
<input type="number" id="them_h_regen" value="0" step="any" />

<input type="number" id="you_h_lifesteal" value="0" step="any" />
<div class="label">Lifesteal (%)</div>
<input type="number" id="them_h_lifesteal" value="0" step="any" />

<div class="sectionTitle" id="skills_title">Skills</div>
<div class="skillsSpacer"></div>
<label id="skills_toggle" class="skillsToggle">
  <input type="checkbox" id="skills_enabled" />
  <span style="font-weight:650;">Enable skills</span>
</label>
<div class="skillsSpacer"></div>

<input type="number" id="you_s_cdr" value="0" step="any" />
<div class="label" id="skillcdr_label">- Skill Cooldown (%)</div>
<input type="number" id="them_s_cdr" value="0" step="any" />

<div id="you_skillSlots">
  <div class="sideStack">
    <div class="skillBox">
      <div class="row"><strong>Skill 1</strong><select id="you_s1_name"></select></div>
      <div class="note" id="you_s1_desc"></div>
      <div id="you_s1_fields"></div>
    </div>
    <div class="skillBox">
      <div class="row"><strong>Skill 2</strong><select id="you_s2_name"></select></div>
      <div class="note" id="you_s2_desc"></div>
      <div id="you_s2_fields"></div>
    </div>
    <div class="skillBox">
      <div class="row"><strong>Skill 3</strong><select id="you_s3_name"></select></div>
      <div class="note" id="you_s3_desc"></div>
      <div id="you_s3_fields"></div>
    </div>
  </div>
</div>
<div class="label" id="skills_slots_label">Skill slots</div>
<div id="them_skillSlots">
  <div class="sideStack">
    <div class="skillBox">
      <div class="row"><strong>Skill 1</strong><select id="them_s1_name"></select></div>
      <div class="note" id="them_s1_desc"></div>
      <div id="them_s1_fields"></div>
    </div>
    <div class="skillBox">
      <div class="row"><strong>Skill 2</strong><select id="them_s2_name"></select></div>
      <div class="note" id="them_s2_desc"></div>
      <div id="them_s2_fields"></div>
    </div>
    <div class="skillBox">
      <div class="row"><strong>Skill 3</strong><select id="them_s3_name"></select></div>
      <div class="note" id="them_s3_desc"></div>
      <div id="them_s3_fields"></div>
    </div>
  </div>
</div>
</div>
<div class="controls">
  <button id="calcBtn" class="calcBtn" type="button">Calculate</button>
</div>

<div class="results">
  <div class="resultCard">
    <div class="highlight" id="you_dps_out">DPS: —</div>
    <div class="highlight" id="you_hps_out">HPS: —</div>
    <div class="muted" id="you_details"></div>
  </div>
  <div class="resultCard">
    <div class="highlight" id="them_dps_out">DPS: —</div>
    <div class="highlight" id="them_hps_out">HPS: —</div>
    <div class="muted" id="them_details"></div>
  </div>
</div>

<div class="centerBox" id="hp_loss_box">
  <div class="highlight">HP loss</div>
  <div class="hpGrid">
    <div>
      <div class="metric">Net HP change: <span id="you_net">—</span></div>
      <div class="metric">%HP lost at 60s: <span id="you_pct">—</span></div>
    </div>
    <div>
      <div class="metric">Net HP change: <span id="them_net">—</span></div>
      <div class="metric">%HP lost at 60s: <span id="them_pct">—</span></div>
    </div>
  </div>
</div>

<div class="muted" id="winner_out" style="text-align:center;margin-top:10px;font-weight:700;"></div>

<div style="margin-top:12px; text-align:center; color:#333; font-size:1em;">
  2025 [OPZ] speedbumps · DPS formulae FIXED (correct game mechanics)
</div>
</div>
</div>

<script>
function $(id) {
  return document.getElementById(id);
}

function isFiniteNumber(x) {
  return (typeof x === 'number') && isFinite(x);
}

function valBy(prefix, idSuffix) {
  var el = $(prefix + '_' + idSuffix);
  var v = el ? parseFloat(el.value) : NaN;
  return isFinite(v) ? v : 0;
}

function setBy(prefix, idSuffix, value) {
  var el = $(prefix + '_' + idSuffix);
  if (el) el.value = String(value);
}

function formatNumber(n) {
  if (!isFinite(n)) return '0.00';
  var abs = Math.abs(n);
  if (abs >= 1000000) return (n / 1000000).toFixed(2) + 'M';
  if (abs >= 1000) return (n / 1000).toFixed(2) + 'K';
  return n.toFixed(2);
}

function clamp01(x) {
  if (!isFinite(x)) return 0;
  return Math.max(0, Math.min(1, x));
}

function effectiveCooldown(cdSeconds, cdrPct) {
  var cd = Math.max(0, Number(cdSeconds) || 0);
  var cdr = clamp01((Number(cdrPct) || 0) / 100);
  return cd * (1 - cdr);
}

// ============================================
// FIXED: Attack Speed Tier System (EXACT from table)
// ============================================
var ATTACK_SPEED_TIERS = [
  { minPercent: 0, maxPercent: 7.1, attackInterval: 1.7 },      // = 0%
  { minPercent: 7.1, maxPercent: 15.4, attackInterval: 1.6 },   // < 7.1%
  { minPercent: 15.4, maxPercent: 25.0, attackInterval: 1.5 },  // < 15.4%
  { minPercent: 25.0, maxPercent: 36.4, attackInterval: 1.4 },  // <= 25.0%
  { minPercent: 36.4, maxPercent: 50.0, attackInterval: 1.3 },  // < 36.4%
  { minPercent: 50.0, maxPercent: 66.7, attackInterval: 1.2 },  // <= 50.0%
  { minPercent: 66.7, maxPercent: 87.5, attackInterval: 1.1 },  // < 66.7%
  { minPercent: 87.5, maxPercent: 114, attackInterval: 1.0 },   // <= 87.5%
  { minPercent: 114, maxPercent: 150, attackInterval: 0.9 },    // < 114%
  { minPercent: 150, maxPercent: 200, attackInterval: 0.8 },    // <= 150%
  { minPercent: 200, maxPercent: 275, attackInterval: 0.7 },    // <= 200%
  { minPercent: 275, maxPercent: 400, attackInterval: 0.6 },    // <= 275%
  { minPercent: 400, maxPercent: Infinity, attackInterval: 0.5 }, // <= 400%
  { minPercent: Infinity, maxPercent: Infinity, attackInterval: 0.4 } // > 400%
];

function getAttackInterval(attackSpeedPercent) {
  // Handle > 400% case first
  if (attackSpeedPercent > 400) {
    return 0.4;
  }
  
  // Find the matching tier
  for (var i = 0; i < ATTACK_SPEED_TIERS.length; i++) {
    var tier = ATTACK_SPEED_TIERS[i];
    if (attackSpeedPercent >= tier.minPercent && attackSpeedPercent < tier.maxPercent) {
      return tier.attackInterval;
    }
  }
  
  // Fallback (should never reach here)
  return 1.7;
}

// ============================================
// FIXED: Attack Rate with Double Attack Delay
// ============================================
function getEffectiveAttackRate(attackInterval, doubleChancePercent, meleeMovementDelay) {
  meleeMovementDelay = meleeMovementDelay || 0;
  var cappedDoubleChance = Math.min(doubleChancePercent, 100) / 100;
  
  // Double attacks add a delay: 0.1s for fast attacks, 0.2s for slow
  var doubleDelay = attackInterval < 1.0 ? 0.1 : 0.2;
  
  var totalTimePerAttack = attackInterval + (cappedDoubleChance * doubleDelay) + meleeMovementDelay;
  return 1 / totalTimePerAttack;
}

// ============================================
// FIXED: Critical Hit Multiplier
// ============================================
function calculateCritMultiplier(critChancePercent, critDamagePercent) {
  var cappedCritChance = Math.min(critChancePercent || 0, 100) / 100;
  var critDamage = (critDamagePercent || 0) / 100;
  
  // Base crit multiplier is 1.2 (120% damage) + additional crit damage
  var critMultiplier = 1.2 + critDamage;
  
  // Expected value: (probability of crit × crit multiplier) + (probability of non-crit × 1.0)
  return (cappedCritChance * critMultiplier) + (1 - cappedCritChance);
}

// ============================================
// FIXED: Double Attack Damage Multiplier
// ============================================
function calculateDoubleMultiplier(doubleChancePercent) {
  var cappedDoubleChance = Math.min(doubleChancePercent || 0, 100) / 100;
  // Expected value: 1 hit + (double chance × 1 extra hit)
  return 1 + cappedDoubleChance;
}

// ============================================
// Core math with FIXED formulas
// ============================================
function computeBaseComponents(prefix) {
  var damage = valBy(prefix, 'e1_damage');
  var speedPct = valBy(prefix, 'e1_speed');
  var dblChancePct = valBy(prefix, 'e1_double');
  var critChancePct = valBy(prefix, 'e1_crit');
  var critDmgPct = valBy(prefix, 'e1_critdmg');
  
  // FIXED: Use tier-based attack interval
  var attackInterval = getAttackInterval(speedPct);
  
  // FIXED: Account for double attack delay
  var attacksPerSec = getEffectiveAttackRate(attackInterval, dblChancePct, 0);
  
  // FIXED: Proper double multiplier
  var dbl = calculateDoubleMultiplier(dblChancePct);
  
  // FIXED: Proper crit expected value
  var crit = calculateCritMultiplier(critChancePct, critDmgPct);
  
  return {
    damage: damage,
    dbl: dbl,
    crit: crit,
    attacksPerSec: attacksPerSec,
    attackInterval: attackInterval
  };
}

function computeHPS(prefix, lifestealDps, effectiveHealth) {
  var regenPct = valBy(prefix, 'h_regen') / 100;
  var lifestealPct = valBy(prefix, 'h_lifesteal') / 100;
  
  // Skill damage does NOT contribute to lifesteal
  return (regenPct * effectiveHealth) + (lifestealPct * lifestealDps);
}

// Skills system (unchanged from original)
var SKILL_FIRST_CAST_AT = 5;
var SKILL_HORIZON = 60;

var FIXED_PROJECTILES = {
  'Meteorite': 5,
  'Stampede': 2,
  'Lightning': 4
};

var FIXED_DURATION = {
  'Morale': 10,
  'Higher Morale': 10
};

var SKILLS = {
  'Meat': { kind: 'buff_hp_flat', desc: 'Increase health by X for X seconds', baseCd: null },
  'Berserk': { kind: 'buff_dmg_flat', desc: 'Increase your damage by X for X seconds', baseCd: null },
  'Morale': { kind: 'buff_both_flat', desc: 'Increase damage by X and health by X for X seconds', baseCd: 8.1 },
  'Higher Morale': { kind: 'buff_both_flat', desc: 'Increase damage by X and health by X for X seconds', baseCd: 8.1 },
  'Thorns': { kind: 'dmg_cast', desc: 'Deal X damage', baseCd: 5.2 },
  'Shout': { kind: 'dmg_cast', desc: 'Deal X damage', baseCd: null },
  'Bomb': { kind: 'dmg_cast', desc: 'Deal X damage', baseCd: 6.2 },
  'Worm': { kind: 'dmg_cast', desc: 'Deal X damage', baseCd: 8.2 },
  'Strafe Run': { kind: 'dmg_cast', desc: 'Deal X damage', baseCd: 10.2 },
  'Arrows': { kind: 'burst', desc: 'Burst of arrows each dealing X damage', baseCd: 10.2 },
  'Shurikens': { kind: 'burst', desc: 'Burst of shurikens each dealing X damage', baseCd: null },
  'Cannon Barrage': { kind: 'burst', desc: 'Burst of cannon balls each dealing X damage', baseCd: null },
  'Meteorite': { kind: 'burst', desc: 'Burst of meteorites each dealing X damage', baseCd: 9.2 },
  'Stampede': { kind: 'burst', desc: 'Bull stampede, each dealing X damage', baseCd: 20.2 },
  'Lightning': { kind: 'burst', desc: 'Bolts each dealing X damage', baseCd: 3.2 },
  'Drone': { kind: 'dot', desc: 'Deal X damage for X seconds', baseCd: 8.1 }
};

var SKILL_ALIASES = {
  'Arrow Rain': 'Arrows',
  'Meteor': 'Meteorite',
  'Strafe': 'Strafe Run',
  'Buff': 'Meat'
};

function skillKeyFromSelection(name) {
  var n = String(name || '');
  return SKILLS[n] ? n : (SKILL_ALIASES[n] || n);
}

function baseCooldownFor(name) {
  var key = skillKeyFromSelection(name);
  var def = SKILLS[key];
  if (!def) return null;
  return isFiniteNumber(def.baseCd) ? def.baseCd : null;
}

function buildSkillSelectOptions(selectEl) {
  var opts = [''];
  for (var k in SKILLS) opts.push(k);
  selectEl.innerHTML = '';
  for (var i = 0; i < opts.length; i++) {
    var name = opts[i];
    var o = document.createElement('option');
    o.value = name;
    o.textContent = name ? name : '(none)';
    selectEl.appendChild(o);
  }
}

function renderSkillFields(prefix, slot) {
  var nameSel = $(prefix + '_' + slot + '_name');
  var fields = $(prefix + '_' + slot + '_fields');
  var descEl = $(prefix + '_' + slot + '_desc');
  if (!nameSel || !fields || !descEl) return;
  
  var chosen = nameSel.value;
  var key = skillKeyFromSelection(chosen);
  var def = SKILLS[key];
  
  if (!chosen || !def) {
    descEl.textContent = '';
    fields.innerHTML = '';
    return;
  }
  
  var baseCdText = isFiniteNumber(def.baseCd) ? (def.baseCd.toFixed(1) + 's') : 'enter';
  var extraPill = '';
  if (FIXED_PROJECTILES[key]) extraPill += ' <span class="pill">Projectiles: ' + FIXED_PROJECTILES[key] + '</span>';
  if (FIXED_DURATION[key]) extraPill += ' <span class="pill">Duration: ' + FIXED_DURATION[key] + 's</span>';
  
  descEl.innerHTML = def.desc + ' <span class="pill">Base CD: ' + baseCdText + '</span>' + extraPill;
  
  var cdVal = baseCooldownFor(chosen);
  var cdId = prefix + '_' + slot + '_cd';
  var durId = prefix + '_' + slot + '_dur';
  var cdDefault = (cdVal === null) ? 0 : cdVal;
  var html = '';
  
  html += '<div class="compactLabel"><span>Cooldown (s)</span><input type="number" id="' + cdId + '" value="' + cdDefault + '" step="any"></div>';
  
  var base = prefix + '_' + slot;
  
  if (def.kind === 'dmg_cast') {
    html += '<div class="compactLabel"><span>Damage (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
  } else if (def.kind === 'burst') {
    html += '<div class="compactLabel"><span>Damage per projectile (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
    if (!FIXED_PROJECTILES[key]) {
      html += '<div class="compactLabel"><span>Projectile count (N)</span><input type="number" id="' + base + '_n" value="0" step="any"></div>';
      html += '<div class="note">Total per cast = X * N.</div>';
    }
  } else if (def.kind === 'dot') {
    html += '<div class="compactLabel"><span>Damage per second (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
    html += '<div class="compactLabel"><span>Duration (s)</span><input type="number" id="' + durId + '" value="0" step="any"></div>';
  } else if (def.kind === 'buff_hp_flat') {
    html += '<div class="compactLabel"><span>Health increase (flat) (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
    html += '<div class="compactLabel"><span>Duration (s)</span><input type="number" id="' + durId + '" value="0" step="any"></div>';
  } else if (def.kind === 'buff_dmg_flat') {
    html += '<div class="compactLabel"><span>Damage increase (flat) (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
    html += '<div class="compactLabel"><span>Duration (s)</span><input type="number" id="' + durId + '" value="0" step="any"></div>';
  } else if (def.kind === 'buff_both_flat') {
    html += '<div class="compactLabel"><span>Damage increase (flat) (X)</span><input type="number" id="' + base + '_x1" value="0" step="any"></div>';
    html += '<div class="compactLabel"><span>Health increase (flat) (X)</span><input type="number" id="' + base + '_x2" value="0" step="any"></div>';
    if (!FIXED_DURATION[key]) {
      html += '<div class="compactLabel"><span>Duration (s)</span><input type="number" id="' + durId + '" value="0" step="any"></div>';
    }
  }
  
  fields.innerHTML = html;
}

function readRenderedSkill(prefix, slot) {
  var nameSel = $(prefix + '_' + slot + '_name');
  var name = nameSel ? nameSel.value : '';
  var key = skillKeyFromSelection(name);
  var def = SKILLS[key];
  if (!name || !def) return { kind: 'none' };
  
  function v(suffix) {
    var el = $(prefix + '_' + slot + '_' + suffix);
    var num = el ? parseFloat(el.value) : NaN;
    return isFinite(num) ? num : 0;
  }
  
  var fixedN = FIXED_PROJECTILES[key] || 0;
  var fixedDur = FIXED_DURATION[key] || 0;
  
  return {
    kind: def.kind,
    name: key,
    cd: v('cd'),
    x1: v('x1'),
    x2: v('x2'),
    dur: fixedDur ? fixedDur : v('dur'),
    n: fixedN ? fixedN : v('n')
  };
}

function isSkillsEnabled() {
  var cb = $('skills_enabled');
  return !!(cb && cb.checked);
}

function countCastsInWindow(windowSeconds, firstCastAt, cooldownSeconds) {
  var W = Math.max(0, Number(windowSeconds) || 0);
  var t0 = Math.max(0, Number(firstCastAt) || 0);
  var cd = Math.max(0, Number(cooldownSeconds) || 0);
  if (W <= 0 || cd <= 0) return 0;
  if (t0 > W) return 0;
  return 1 + Math.floor((W - t0) / cd);
}

function unionActiveSeconds(windowSeconds, firstCastAt, cooldownSeconds, durationSeconds) {
  var W = Math.max(0, Number(windowSeconds) || 0);
  var t0 = Math.max(0, Number(firstCastAt) || 0);
  var cd = Math.max(0, Number(cooldownSeconds) || 0);
  var dur = Math.max(0, Number(durationSeconds) || 0);
  if (W <= 0 || cd <= 0 || dur <= 0) return 0;
  if (t0 > W) return 0;
  
  var intervals = [];
  for (var t = t0; t <= W; t += cd) {
    var a = t;
    var b = Math.min(W, t + dur);
    if (b > a) intervals.push([a, b]);
  }
  if (!intervals.length) return 0;
  
  intervals.sort(function (i1, i2) { return i1[0] - i2[0]; });
  
  var total = 0;
  var curA = intervals[0][0];
  var curB = intervals[0][1];
  for (var i = 1; i < intervals.length; i++) {
    var a2 = intervals[i][0];
    var b2 = intervals[i][1];
    if (a2 <= curB) {
      curB = Math.max(curB, b2);
    } else {
      total += (curB - curA);
      curA = a2;
      curB = b2;
    }
  }
  total += (curB - curA);
  return total;
}

function computeSkillsImpact(prefix) {
  if (!isSkillsEnabled()) {
    return { extraSkillDps: 0, avgAddDamage: 0, avgAddHealth: 0 };
  }
  
  var cdrPct = valBy(prefix, 's_cdr');
  var skills = [
    readRenderedSkill(prefix, 's1'),
    readRenderedSkill(prefix, 's2'),
    readRenderedSkill(prefix, 's3')
  ];
  
  var extraSkillDps = 0;
  var avgAddDamage = 0;
  var avgAddHealth = 0;
  
  for (var i = 0; i < skills.length; i++) {
    var s = skills[i];
    if (s.kind === 'none') continue;
    
    var ecd = effectiveCooldown(s.cd, cdrPct);
    if (ecd <= 0) continue;
    
    if (s.kind === 'dmg_cast') {
      var casts = countCastsInWindow(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd);
      var total = (s.x1 || 0) * casts;
      if (total > 0) extraSkillDps += total / SKILL_HORIZON;
    } else if (s.kind === 'burst') {
      var castsB = countCastsInWindow(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd);
      var perCast = (s.x1 || 0) * Math.max(0, s.n || 0);
      var totalB = perCast * castsB;
      if (totalB > 0) extraSkillDps += totalB / SKILL_HORIZON;
    } else if (s.kind === 'dot') {
      var active = unionActiveSeconds(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd, s.dur || 0);
      var totalDot = (s.x1 || 0) * active;
      if (totalDot > 0) extraSkillDps += totalDot / SKILL_HORIZON;
    } else if (s.kind === 'buff_hp_flat') {
      var upHp = unionActiveSeconds(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd, s.dur || 0);
      avgAddHealth += (s.x1 || 0) * (upHp / SKILL_HORIZON);
    } else if (s.kind === 'buff_dmg_flat') {
      var upDmg = unionActiveSeconds(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd, s.dur || 0);
      avgAddDamage += (s.x1 || 0) * (upDmg / SKILL_HORIZON);
    } else if (s.kind === 'buff_both_flat') {
      var upBoth = unionActiveSeconds(SKILL_HORIZON, SKILL_FIRST_CAST_AT, ecd, s.dur || 0);
      var frac = upBoth / SKILL_HORIZON;
      avgAddDamage += (s.x1 || 0) * frac;
      avgAddHealth += (s.x2 || 0) * frac;
    }
  }
  
  return {
    extraSkillDps: extraSkillDps,
    avgAddDamage: avgAddDamage,
    avgAddHealth: avgAddHealth
  };
}

function calculateSide(prefix) {
  var base = computeBaseComponents(prefix);
  var baseHealth = valBy(prefix, 'h_total');
  var skills = computeSkillsImpact(prefix);
  
  var effDamage = base.damage + skills.avgAddDamage;
  var effHealth = baseHealth + skills.avgAddHealth;
  
  var autoAttackDps = effDamage * base.dbl * base.crit * base.attacksPerSec;
  var totalDps = autoAttackDps + skills.extraSkillDps;
  
  var totalHps = computeHPS(prefix, autoAttackDps, effHealth);
  
  var dpsEl = $(prefix + '_dps_out');
  var hpsEl = $(prefix + '_hps_out');
  var detailsEl = $(prefix + '_details');
  
  if (dpsEl) dpsEl.textContent = 'DPS: ' + formatNumber(totalDps);
  if (hpsEl) hpsEl.textContent = 'HPS: ' + formatNumber(totalHps);
  
  var lifestealPart = (valBy(prefix, 'h_lifesteal') / 100) * autoAttackDps;
  var regenPart = (valBy(prefix, 'h_regen') / 100) * effHealth;
  
  if (detailsEl) {
    detailsEl.textContent = 
      'Auto-attack DPS: ' + formatNumber(autoAttackDps) + '\n' +
      'Skill DPS added (avg over 60s, starts at 5s): ' + formatNumber(skills.extraSkillDps) + '\n' +
      'Avg +Damage from buffs: ' + formatNumber(skills.avgAddDamage) + '\n' +
      'Avg +Health from buffs: ' + formatNumber(skills.avgAddHealth) + '\n' +
      'Effective Damage used: ' + formatNumber(effDamage) + '\n' +
      'Effective Health used: ' + formatNumber(effHealth) + '\n' +
      'Attack interval: ' + base.attackInterval.toFixed(2) + 's\n' +
      'Attacks per second: ' + base.attacksPerSec.toFixed(3) + '\n' +
      'Double multiplier: ' + base.dbl.toFixed(3) + 'x\n' +
      'Crit multiplier: ' + base.crit.toFixed(3) + 'x\n' +
      'Lifesteal contribution (auto-attack only): ' + formatNumber(lifestealPart) + '\n' +
      'Regen contribution: ' + formatNumber(regenPart);
  }
  
  return {
    totalDps: totalDps,
    totalHps: totalHps,
    effHealth: effHealth,
    effDamage: effDamage
  };
}

function computeOutcome(youRes, themRes) {
  var PVP_HP_MULT = 5;
  
  function outcomeFor(selfRes, oppRes) {
    var profileHp = Math.max(0, Number(selfRes.effHealth) || 0);
    var pvpHp = profileHp * PVP_HP_MULT;
    var incoming = Math.max(0, Number(oppRes.totalDps) || 0);
    var sustain = Math.max(0, Number(selfRes.totalHps) || 0);
    var deficitPerSec = incoming - sustain;
    var lossPerSec = Math.max(0, deficitPerSec);
    var loss60 = lossPerSec * 60;
    var cappedLoss60 = pvpHp > 0 ? Math.min(pvpHp, loss60) : 0;
    var pctLost = pvpHp > 0 ? (cappedLoss60 / pvpHp) : 0;
    var netPerSec = sustain - incoming;
    var timeToZero = (deficitPerSec > 0 && pvpHp > 0) ? (pvpHp / deficitPerSec) : Infinity;
    
    return {
      netPerSec: netPerSec,
      pctLost: pctLost,
      profileHp: profileHp,
      pvpHp: pvpHp,
      deficitPerSec: deficitPerSec,
      timeToZero: timeToZero
    };
  }
  
  var youOut = outcomeFor(youRes, themRes);
  var themOut = outcomeFor(themRes, youRes);
  
  var youNetEl = $('you_net');
  var themNetEl = $('them_net');
  var youPctEl = $('you_pct');
  var themPctEl = $('them_pct');
  
  if (youNetEl) {
    if (youOut.netPerSec > 0) {
      youNetEl.textContent = 'Regen too high';
    } else {
      youNetEl.textContent = formatNumber(youOut.netPerSec) + ' HP/s';
    }
  }
  
  if (themNetEl) {
    if (themOut.netPerSec > 0) {
      themNetEl.textContent = 'Regen too high';
    } else {
      themNetEl.textContent = formatNumber(themOut.netPerSec) + ' HP/s';
    }
  }
  
  if (youPctEl) youPctEl.textContent = (youOut.pctLost * 100).toFixed(1) + '%';
  if (themPctEl) themPctEl.textContent = (themOut.pctLost * 100).toFixed(1) + '%';
  
  function setGoodBad(aEl, bEl, aBetter) {
    if (!aEl || !bEl) return;
    aEl.classList.remove('good', 'bad');
    bEl.classList.remove('good', 'bad');
    aEl.classList.add(aBetter ? 'good' : 'bad');
    bEl.classList.add(aBetter ? 'bad' : 'good');
  }
  
  setGoodBad(
    youNetEl,
    themNetEl,
    (youOut.netPerSec > 0 && themOut.netPerSec <= 0) || (youOut.netPerSec >= themOut.netPerSec)
  );
  
  setGoodBad(youPctEl, themPctEl, youOut.pctLost >= themOut.pctLost);
  
  var winnerEl = $('winner_out');
  if (winnerEl) {
    var tYou = youOut.timeToZero;
    var tThem = themOut.timeToZero;
    var msg = '';
    
    if (tYou <= 60 || tThem <= 60) {
      if (tYou < tThem) {
        msg = 'You lose 100% health with ' + formatNumber(60 - tYou) + ' seconds remaining.';
      } else if (tThem < tYou) {
        msg = 'They lose 100% health with ' + formatNumber(60 - tThem) + ' seconds remaining.';
      } else {
        msg = 'Both reach 0 health with ' + formatNumber(60 - tYou) + ' seconds remaining (tie).';
      }
    } else {
      var eps = 1e-9;
      if (Math.abs(youOut.pctLost - themOut.pctLost) < eps) {
        msg = 'After 60s: Tie (equal %HP lost).';
      } else if (youOut.pctLost > themOut.pctLost) {
        msg = 'After 60s: You lose (higher %HP lost).';
      } else {
        msg = 'After 60s: You win (they lose more %HP).';
      }
    }
    
    winnerEl.textContent = msg;
  }
  
  return { you: youOut, them: themOut };
}

function calculateAll() {
  var youRes = calculateSide('you');
  var themRes = calculateSide('them');
  computeOutcome(youRes, themRes);
}

function clearResults(prefix) {
  var dpsEl = $(prefix + '_dps_out');
  var hpsEl = $(prefix + '_hps_out');
  var detailsEl = $(prefix + '_details');
  if (dpsEl) dpsEl.textContent = 'DPS: —';
  if (hpsEl) hpsEl.textContent = 'HPS: —';
  if (detailsEl) detailsEl.textContent = '';
  
  var youNetEl = $('you_net');
  var themNetEl = $('them_net');
  var youPctEl = $('you_pct');
  var themPctEl = $('them_pct');
  
  if (youNetEl) {
    youNetEl.textContent = '—';
    youNetEl.classList.remove('good','bad');
  }
  if (themNetEl) {
    themNetEl.textContent = '—';
    themNetEl.classList.remove('good','bad');
  }
  if (youPctEl) {
    youPctEl.textContent = '—';
    youPctEl.classList.remove('good','bad');
  }
  if (themPctEl) {
    themPctEl.textContent = '—';
    themPctEl.classList.remove('good','bad');
  }
  
  var winnerEl = $('winner_out');
  if (winnerEl) winnerEl.textContent = '';
}

function clearSide(prefix) {
  var coreIds = ['e1_damage','e1_speed','e1_double','e1_crit','e1_critdmg','h_total','h_regen','h_lifesteal'];
  for (var i = 0; i < coreIds.length; i++) setBy(prefix, coreIds[i], 0);
  
  setBy(prefix, 's_cdr', 0);
  
  var slots = ['s1','s2','s3'];
  for (var s = 0; s < slots.length; s++) {
    var slot = slots[s];
    var sel = $(prefix + '_' + slot + '_name');
    if (sel) sel.value = '';
    var desc = $(prefix + '_' + slot + '_desc');
    if (desc) desc.textContent = '';
    var fields = $(prefix + '_' + slot + '_fields');
    if (fields) fields.innerHTML = '';
  }
  
  clearResults(prefix);
}

function applySkillsVisibilityAll() {
  var enabled = isSkillsEnabled();
  var title = $('skills_title');
  var slotsLabel = $('skills_slots_label');
  var cdrLabel = $('skillcdr_label');
  
  if (title) title.style.display = enabled ? 'block' : 'none';
  if (slotsLabel) slotsLabel.style.display = enabled ? 'block' : 'none';
  if (cdrLabel) cdrLabel.style.display = enabled ? 'block' : 'none';
  
  var ids = ['you_s_cdr','them_s_cdr','you_skillSlots','them_skillSlots'];
  for (var i = 0; i < ids.length; i++) {
    var el = $(ids[i]);
    if (!el) continue;
    el.style.display = enabled ? 'block' : 'none';
  }
}

function initSide(prefix) {
  var slots = ['s1','s2','s3'];
  for (var i = 0; i < slots.length; i++) {
    var slot = slots[i];
    var sel = $(prefix + '_' + slot + '_name');
    if (!sel) continue;
    buildSkillSelectOptions(sel);
    (function (p, s) {
      sel.addEventListener('change', function () {
        renderSkillFields(p, s);
      });
    })(prefix, slot);
    renderSkillFields(prefix, slot);
  }
  
  var clearBtn = $(prefix + '_clear');
  if (clearBtn) clearBtn.addEventListener('click', function () {
    clearSide(prefix);
  });
  
  clearResults(prefix);
}

document.addEventListener('DOMContentLoaded', function () {
  initSide('you');
  initSide('them');
  
  var btn = $('calcBtn');
  if (btn) btn.addEventListener('click', calculateAll);
  
  var skillsCb = $('skills_enabled');
  if (skillsCb) {
    skillsCb.checked = false;
    skillsCb.addEventListener('change', applySkillsVisibilityAll);
  }
  
  applySkillsVisibilityAll();
  
  console.log('✅ Fixed PvP Calculator loaded with correct formulas!');
  console.log('Changes:');
  console.log('1. Critical multiplier: (1-critChance)*1 + critChance*(1.2+critDmg)');
  console.log('2. Attack speed: Tier-based intervals (1.0s down to 0.26s)');
  console.log('3. Double attacks: Include 0.1s/0.2s delay per double');
});
</script>
</body>
</html>
